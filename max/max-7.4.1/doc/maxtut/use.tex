
\chapter{Using the MAX System}

This chapter explains how to use the MAX system. After showing how to call
the generated evaluator, we describe the interface between MAX and C.
Finally, we give the specification of an interpreter for TIFL in order to
illustrate how MAX can interact with C-programs and thus how it can
be used to stepwise refine language specifications.


\section{Getting started}
         
This section introduces to the application of the MAX system; first, we present two figures to illustrate the handling of MAX (explanations below):
\\

%------  hier usepic.eps
\psfig{figure=usepic.eps}

\noindent
To create a compiler for a specific language the following steps have to be taken:
\begin{itemize}
\item The first task consists of designing the abstract syntax of the language ($\langle$language\_spec.m$\rangle$ contains the specification);
\item the second step is providing a parser for the language (e.g. using a tool like YACC);
\item third: a main program to control the phases (parsing, semantical analysis etc.) has to be written ($\langle$language.c$\rangle$).
\end{itemize}
\noindent
The skeleton of the main program looks like this:
\begin{verbatim}
#include "<language_spec.h>"   /*  establishing the interface MAX <-> C  */
#include "..."

/* function definitions  */

int main(int argc, char **argv)
{
  ELEMENT termvar;

   ...

  /*  call of parser  */

  termvar = <program term>;

  /*  structure construction  */

  init_<language>(termvar);

  /*  evaluates the ``struc'' specification */  

}
\end{verbatim} 
\noindent
The call of init\_$\langle$language$\rangle$ performs the construction of the syntax tree, the attribution and checking of context conditions according to the specification in $\langle$language\_spec.m$\rangle$. 
\noindent
MAX generates two files from a specification: $\langle$language\_spec.h$\rangle$ and $\langle$language\_spec.c$\rangle$. Together with the parser module, the main program and max\_std.o (contains predefined constants and functions) these files form the input to the C-compiler, which generates the executable compiler (named $\langle$language$\rangle$).\\

  
\section{Standard Functions}
This section presents the predefined standard functions of the MAX system interface to C.\\
For each function we give the functionality and a short description; if their obvious meaning is not defined, they return nil().\\
"ELEMENT" is the C-type for all elements of the MAX universe (cf. section 2.2) (including nil()). These functions can be used from within C by including the $\langle$language\_spec.h$\rangle$ generated by the MAX system (cf. Appendix). This file also contains the definition of the sort constants; in addition to
 the predefined sorts (like Ident,String,Int,Bool,...) there are sort constants for each sort defined in the 
abstract syntax. These constants can be used e.g. to determine, whether a given ELEMENT is of a particular sort
( $\rightarrow$ is(ELEMENT,Sort), where Sort is a sort constant). The sorting on nodes is imported from the corresponding terms (cf. section 2.2).\\
%--------------conversion  C -> MAX
\subsection{Conversion C $\rightarrow$ MAX}
The functions below convert the C-types long,char etc. to ELEMENT.
\begin{verbatim}
ELEMENT  btoe(long)         /* converts boolean value(long) to ELEMENT */       
ELEMENT  ctoe(char)         /* converts char to ELEMENT  */
ELEMENT  itoe(long)         /* converts long int to ELEMENT */
ELEMENT  atoe(char*)        /* converts string(char*) to ELEMENT */
\end{verbatim}
       
%--------------conversion  MAX -> C
\subsection{Conversion MAX $\rightarrow$ C}
The functions below convert ELEMENT to C-types.
\begin{verbatim}
long     etob(ELEMENT)      /* converts ELEMENT to boolean value (long)*/
char     etoc(ELEMENT)      /* converts ELEMENT to char */
long     etoi(ELEMENT)      /* converts ELEMENT to long int */ 
char*    etoa(ELEMENT)      /* converts ELEMENT to string (char*) */
\end{verbatim}
       
%--------------conversion  MAX -> MAX
\subsection{Conversion within MAX}
There are two functions for conversion within the MAX system:
\begin{verbatim}
Ident    stoid(String)       /* converts string to ident */       
String   idtos(Ident)        /* converts ident to string */
\end{verbatim}

%--------------index functions
\subsection{Index Functions}
\begin{verbatim}
ELEMENT  index(ELEMENT,Sort) /* returns index of ELEMENT in Sort */
ELEMENT  element(index,Sort) /* returns ELEMENT with index in Sort */
ELEMENT  number(Sort)        /* returns number of nodes of Sort */
\end{verbatim}

%--------------tree functions
\subsection{Tree Functions}
\begin{verbatim}
ELEMENT  fath(Node)          /* returns father of Node */
ELEMENT  lbroth(Node)        /* returns left brother of Node */
ELEMENT  rbroth(Node)        /* returns right brother of Node */
ELEMENT  son(ith,Node)       /* returns ith son of Node */
ELEMENT  numsons(Node)       /* returns number of sons of Node */
\end{verbatim}

%--------------general term functions
\subsection{General Term Functions}
\begin{verbatim}
ELEMENT  subterm(ith,Term)   /* returns ith subterm of Term */
ELEMENT  numsubterms(Term)   /* returns number of subterms of Term */
\end{verbatim}
%--------------polymorphic list handling (special term functions -> lists)
\subsection{Polymorphic List Handling Functions}
\begin{verbatim}
ELEMENT  front(List)             /* returns first ELEMENT of List */
ELEMENT  back(List)              /* returns List without first ELEMENT */
ELEMENT  appfront(ELEMENT,List)  /* appends ELEMENT in front of List */
ELEMENT  appback(List,ELEMENT)   /* appends ELEMENT at the end of List */
ELEMENT  conc(List,List)         /* concatenates two Lists */
\end{verbatim}
%--------------additional functions
\subsection{Additional Functions}
\begin{verbatim}
ELEMENT  term(Node)    /* returns the corresponding order-sorted term */
ELEMENT  sort(ELEMENT)           /* returns sort of ELEMENT */

long     eq(ELEMENT,ELEMENT)     /* equality predicate */    
long     is(ELEMENT,Sort)        /* sort predicate */
long     desc(Node,Node)         /* descendant predicate */            
\end{verbatim}

\section{External Functions}
For some purposes, it is helpful or necessary to implement functions used in the specification in C. This can be done by declaring the function in the specification and defining it in some C-file. We give an example for this technique below:
\begin{verbatim}
in the specification (tifl_spec.m):

FCT add( Int, Int ) Int

in the main program (tifl.c):

ELEMENT add( ELEMENT o1, ELEMENT o2 ){ return itoe(etoi(o1)+etoi(o2)); }

\end{verbatim}

\section{Implementation of an Interpreter for TIFL}
This section deals with the specification and implementation of an interpreter for TIFL. We present two different implementations, one using the environment technique, the other operating with a stack mechanism (implemented in C).
\subsection{The Interpreter using Environments}
First, we give the additional sort declarations in the abstract syntax and the specification of the interpreter itsself (explanations below, complete sources in the appendix):
\begin{verbatim}
Env          *  Pair
Pair         (  ParDecl@  Value  )
Value        =  Bool | Int


FCT  env_lookup( ParDecl@ PN, Env E ) Value:
   IF  subterm(1,subterm(1,E)) = PN  :  subterm(2,subterm(1,E))
                                  ELSE  env_lookup( PN, back(E) )

FCT  enter_pars( ParDecl@ PN, Exp@ EN, Env E, Env EVALENV ) Env:
   LET  V == eval( EN, EVALENV )   :
   IF   rbroth(PN) = nil()   :	appfront( Pair(PN,V), E )
   ELSE   enter_pars( rbroth(PN), rbroth(EN), 
                        appfront( Pair(PN,V), E ), EVALENV )
\end{verbatim}
\pagebreak
\begin{verbatim}

FCT  eval ( Exp@ X, Env E ) Value:
   IF  LetExp@<_,BD>        X:  eval( BD, E )
    |  Int@                 X:  term(X)
    |  Bool@                X:  term(X)
    |  CondExp@<E1,E2,E3>   X:  IF eval(E1,E) = true() : eval(E2,E)
                                ELSE                     eval(E3,E) 
    |  UsedId@              X:  env_lookup( fath(decl(X)), E )
    |  FctAppl@<UID,<>>     X:  eval( son(4, UID.decl.fath ), E )
    |  FctAppl@<UID,<E1,*>> X:  LET  FCTDCL ==  UID.decl.fath  :
	IF  FctDecl@<_,<IDN,_>,_,PredeclBody@> FCTDCL:  
               eval_predecl( term(IDN), E1, E )
	ELSE   eval( son(4,FCTDCL), enter_pars(son(1,son(3,FCTDCL)),E1,E,E)  )
   ELSE nil()

\end{verbatim}
Environments consist of a list of pairs, each constructed of a parameter (its declaration occurrence) and the corresponding actual value (which is either a Bool or Int).
eval yields the value of the expression in the given environment.It works together with three auxiliary functions:
\begin{itemize}
\item env\_lookup() : returns the value of given parameter in a given environment;
\item eval\_predecl() : evaluates the application of predeclared functions,e.g. "+" (cf. appendix);
\item enter\_pars() : inserts the actual values of the formal parameters of a given function in a given environment.
\end{itemize}
\noindent
The interpreter is fully specified within the MAX system; it is called by the main program:
\begin{verbatim}

ELEMENT eval_result;            
eval_result =  eval( son(1,root()), Env() );
                
\end{verbatim}

\subsection{The Interpreter using the Stack Mechanism}
In the following we give the necessary sort declarations, the specification of the interpreter using the stack mechanism and the related C-implementation (explanations below, complete sources in the appendix):
\begin{verbatim}

Value        =  Bool | Int

FCT  par_lookup( ParDecl@ ) Value

FCT  eval_userfunc( ParDecl@, Exp@, Exp@ ) Value

FCT  eval ( Exp@ X ) Value:
   IF  LetExp@<_,BD>        X:  eval( BD )
    |  Int@                 X:  term(X)
    |  Bool@                X:  term(X)
    |  CondExp@<E1,E2,E3>   X:  IF eval(E1) = true() :  eval(E2)  
                                                  ELSE  eval(E3) 
    |  UsedId@              X:  par_lookup( fath(decl(X)) )
    |  FctAppl@<UID,<>>     X:  eval( son(4, UID.decl.fath ) )
    |  FctAppl@<UID,<E1,*>> X:  LET  FCTDCL ==  UID.decl.fath  :
	IF  FctDecl@<_,<IDN,_>,_,PredeclBody@> FCTDCL:  
               eval_predecl( term(IDN), E1 )
	ELSE   eval_userfunc( son(1,son(3,FCTDCL)), E1, son(4,FCTDCL) )
   ELSE nil()

\end{verbatim}
The stack implementation in C looks like this:
\begin{verbatim}

/*----------------------------------------------------------------------

  stack.c           
                   
  --------------------------------------------------------------------*/

#define MAX_NUM_PAR 50
#define MAX_DEPTH 100      

ELEMENT stacks[MAX_NUM_PAR][MAX_DEPTH];
int sp[MAX_NUM_PAR];


void pop_params( ELEMENT Parnode )
{
  while( Parnode != nil() )
       {
        sp[index(Parnode,_ParDecl_)]--;
        Parnode = rbroth(Parnode);
       }
}


void push_params( ELEMENT Parnode, ELEMENT Expnode )
{
  long indx;
  ELEMENT n;
  ELEMENT to_push[MAX_NUM_PAR];

  /* first, evaluate all actual parameter expressions;
     then push them on the stacks
  */

  n = Parnode;
  while( n != nil() )
       {
        to_push[index( n, _ParDecl_ )] = eval( Expnode );
        Expnode = rbroth( Expnode );
        n = rbroth( n );
       }


  while( Parnode != nil() )
       {
        indx = index(Parnode, _ParDecl_);

        if( sp[ indx ] > MAX_DEPTH )
          {
           printf("\n!!! RUNTIME error: stack overflow\n");
           return;
          }

         sp[ indx ]++;
         stacks[ indx ][ sp[indx] ] = to_push[ index(Parnode,_ParDecl_) ];
         Parnode = rbroth(Parnode);
       }
}
\end{verbatim}
\pagebreak
\begin{verbatim}
ELEMENT par_lookup( ELEMENT Parnode )
{
  long indx = index(Parnode, _ParDecl_);
  return stacks[ indx ][ sp[ indx ] ];
}


ELEMENT eval_userfunc( ELEMENT Parnode, ELEMENT Expnode, ELEMENT Body )
{
   ELEMENT result;

   push_params( Parnode, Expnode );
   result = eval(Body);    
   pop_params( Parnode );
   return result; 
}

\end{verbatim}
Since we operate with stacks now, we do not need any environments. The functions used are:
\begin{itemize}
\item par\_lookup() : returns the actual value of a formal parameter (implemented in C);
\item eval\_userfunc() : evaluates a given user-defined function with given actual parameters (implemented in C);
\item eval\_predecl() : same as above (besides the fact, that environments are no longer needed);
\item eval() : same as above (besides the fact, that environments are no longer needed).
\end{itemize}
The stack mechanism itself is implemented in a straightforward way. Each parameter has its own stack which is accessed by the following functions:
\begin{itemize}
\item eval\_userfunc() : pushes the actual parameters on the corresponding stacks($\rightarrow$ push\_params())($\rightarrow$ push\_params()), evaluates the body of the function, pops the parameters($\rightarrow$ pop\_params()) and returns the result of the evaluation;
\item par\_lookup() : returns top of stack of given parameter.
\end{itemize}
The application in the main program looks like this:
\pagebreak
\begin{verbatim}

ELEMENT eval_result;

/*---------------------------------------
check if there are enough stacks available
---------------------------------------*/
if ((np = number(_ParDecl_)) > MAX_NUM_PAR)
   { 
    printf("\n!!! RUNTIME error: too many parameters\n");
    return EXIT_FAILURE;
   }

eval_result =  eval( son(1,root()) );

\end{verbatim}

